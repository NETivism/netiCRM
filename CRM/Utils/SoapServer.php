<?php
/*
 +--------------------------------------------------------------------+
 | CiviCRM version 3.3                                                |
 +--------------------------------------------------------------------+
 | Copyright CiviCRM LLC (c) 2004-2010                                |
 +--------------------------------------------------------------------+
 | This file is a part of CiviCRM.                                    |
 |                                                                    |
 | CiviCRM is free software; you can copy, modify, and distribute it  |
 | under the terms of the GNU Affero General Public License           |
 | Version 3, 19 November 2007 and the CiviCRM Licensing Exception.   |
 |                                                                    |
 | CiviCRM is distributed in the hope that it will be useful, but     |
 | WITHOUT ANY WARRANTY; without even the implied warranty of         |
 | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.               |
 | See the GNU Affero General Public License for more details.        |
 |                                                                    |
 | You should have received a copy of the GNU Affero General Public   |
 | License and the CiviCRM Licensing Exception along                  |
 | with this program; if not, contact CiviCRM LLC                     |
 | at info[AT]civicrm[DOT]org. If you have questions about the        |
 | GNU Affero General Public License or the licensing of CiviCRM,     |
 | see the CiviCRM license FAQ at http://civicrm.org/licensing        |
 +--------------------------------------------------------------------+
*/

/**
 *
 * @package CRM
 * @copyright CiviCRM LLC (c) 2004-2010
 * $Id$
 *
 */

/**
 * This class handles all SOAP client requests.
 *
 * @package CRM
 * @copyright CiviCRM LLC (c) 2004-2010
 * $Id$
 *
 */



class CRM_Utils_SoapServer {

  /**
   * Number of seconds we should let a soap process idle
   * @static
   */
  static $soap_timeout = 0;

  /**
   * Cache the actual UF Class
   */
  public $ufClass;

  /**
   * Class constructor.  This caches the real user framework class locally,
   * so we can use it for authentication and validation.
   *
   * @param  string $uf       The userframework class
   */
  public function __construct() {
    // any external program which call SoapServer is responsible for
    // creating and attaching the session
    $args = func_get_args();
    $this->ufClass = array_shift($args);
  }

  /**
   * Simple ping function to test for liveness.
   *
   * @param string $var   The string to be echoed
   *
   * @return string       $var
   * @access public
   */
  public function ping($var) {
    $session = CRM_Core_Session::singleton();
    $key = $session->get('key');
    $session->set('key', $var);
    return "PONG: $var ($key)";
  }

  /**
   * Verify a SOAP key
   *
   * @param string $key   The soap key generated by authenticate()
   *
   * @return none
   * @access public
   */
  public function verify($key) {
    $session = CRM_Core_Session::singleton();

    $soap_key = $session->get('soap_key');
    $t = time();

    if ($key !== sha1($soap_key)) {
      throw new SoapFault('Client', 'Invalid key');
    }


    if (self::$soap_timeout &&
      $t > ($session->get('soap_time') + self::$soap_timeout)
    ) {
      throw new SoapFault('Client', 'Expired key');
    }

    /* otherwise, we're ok.  update the timestamp */

    $session->set('soap_time', $t);
  }

  /**
   * Authentication wrapper to the UF Class
   *
   * @param string $name      Login name
   * @param string $pass      Password
   *
   * @return string           The SOAP Client key
   * @access public
   * @static
   */
  public function authenticate($name, $pass) {
    $ufClassName = $this->ufClass;
    $result =& $ufClassName::authenticate($name, $pass);

    if (empty($result)) {
      throw new SoapFault('Client', 'Invalid login');
    }

    $session = CRM_Core_Session::singleton();
    $session->set('soap_key', $result[2]);
    $session->set('soap_time', time());

    return sha1($result[2]);
  }

  /*** MAILER API ***/
  public function mailer_event_bounce($key, $job, $queue, $hash, $body) {
    $this->verify($key);
    $params = ['job_id' => $job,
      'event_queue_id' => $queue,
      'hash' => $hash,
      'body' => $body,
    ];
    return civicrm_mailer_event_bounce($params);
  }

  public function mailer_event_unsubscribe($key, $job, $queue, $hash) {
    $this->verify($key);
    $params = ['job_id' => $job,
      'event_queue_id' => $queue,
      'hash' => $hash,
    ];
    return civicrm_mailer_event_unsubscribe($params);
  }

  public function mailer_event_domain_unsubscribe($key, $job, $queue, $hash) {
    $this->verify($key);
    $params = ['job_id' => $job,
      'event_queue_id' => $queue,
      'hash' => $hash,
    ];
    return civicrm_mailer_event_domain_unsubscribe($params);
  }

  public function mailer_event_resubscribe($key, $job, $queue, $hash) {
    $this->verify($key);
    $params = ['job_id' => $job,
      'event_queue_id' => $queue,
      'hash' => $hash,
    ];
    return civicrm_mailer_event_resubscribe($params);
  }

  public function mailer_event_subscribe($key, $email, $domain, $group) {
    $this->verify($key);
    $params = ['email' => $email,
      'group_id' => $group,
    ];
    return civicrm_mailer_event_subscribe($params);
  }

  public function mailer_event_confirm($key, $contact, $subscribe, $hash) {
    $this->verify($key);
    $params = ['contact_id' => $contact,
      'subscribe_id' => $subscribe,
      'hash' => $hash,
    ];
    return civicrm_mailer_event_confirm($params);
  }

  public function mailer_event_reply($key, $job, $queue, $hash, $bodyTxt, $rt, $bodyHTML = NULL, $fullEmail = NULL) {
    $this->verify($key);
    $params = ['job_id' => $job,
      'event_queue_id' => $queue,
      'hash' => $hash,
      'bodyTxt' => $bodyTxt,
      'replyTo' => $rt,
      'bodyHTML' => $bodyHTML,
      'fullEmail' => $fullEmail,
    ];
    return civicrm_mailer_event_reply($params);
  }

  public function mailer_event_forward($key, $job, $queue, $hash, $email) {
    $this->verify($key);
    $params = ['job_id' => $job,
      'event_queue_id' => $queue,
      'hash' => $hash,
      'email' => $email,
    ];
    return civicrm_mailer_event_forward($params);
  }

  public function get_contact($key, $params) {
    $this->verify($key);

    return civicrm_contact_get($params);
  }
}

